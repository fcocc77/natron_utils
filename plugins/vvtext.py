# esta linea es necesaria para que natron reconosta este archivo como un plugin de natron :
# This file was automatically generated by Natron PyPlug exporter
# --------------------

import NatronEngine
import sys
from util import *
from natron import *
import os


def getPluginID():
    return 'vv.text'


def getLabel():
    return 'VVText'


def getVersion():
    return 1


def getIconPath():
    return 'Text.png'


def getGrouping():
    return 'videovina'


def getPluginDescription():
    return 'Animacion de Textos'


def createInstance(app, group):
    group.controls = group.createPageParam("controls", "Controls")

    createParam(group, 'text', 'string')

    direction = createParam(group, 'direction', 'choice')
    direction.addOption('Left to Right', 'Left to Right')
    direction.addOption('Right to Left', 'Right to Left')

    createParam(group, 'separator')
    createParam(group, 'delay', 'float')

    createParam(group, 'separator')
    createParam(group, 'scale', 'float', [1, 100])
    createParam(group, 'position_y', 'int', [0, 1920])
    createParam(group, 'position_x', 'int', [0, 1080])
    createParam(group, 'rotate', 'float', [0, 360])
    createParam(group, 'opacity', 'float', [0, 1]).setValue(1)

    createParam(group, 'separator')
    createParam(group, 'blur_x', 'float', [0, 100])
    createParam(group, 'blur_y', 'float', [0, 100])

    createParam(group, 'separator')
    createParam(group, 'update', 'button')

    group.onParamChanged.set('vvtext.update_button')

    app.createNode('fr.inria.built-in.Output', -1, group)

    # cambia el orden de la primera pestania y actualiza
    group.setPagesOrder(['controls', 'Node'])
    group.refreshUserParamsGUI()
    # ----------------------


created_nodes = []


def update_button(thisParam, thisNode, thisGroup, app, userEdited):

    # defina la app y el nodo como variables globales,
    # para poder acceder de otras funcciones
    global _app
    global _thisNode
    _app = app
    _thisNode = thisNode
    # ----------------------

    button_name = thisParam.getScriptName()
    if button_name == 'update_param':
        deleteNodes()
        create_word()

    debug_show()


def createNode(name):
    nodes = {
        'blur': 'net.sf.cimg.CImgBlur',
        'text': 'net.fxarena.openfx.Text',
        'transform': 'net.sf.openfx.TransformPlugin',
        'merge': 'net.sf.openfx.MergePlugin',
        'output': 'fr.inria.built-in.Output'
    }

    node_name = _app.createNode(nodes[name], -1, _thisNode).getScriptName()
    node = getattr(_thisNode, node_name)

    node.setScriptName(name + '_' + hash_generator(7))

    created_nodes.append(node)
    return node


def deleteNodes():
    for node in created_nodes:
        node.destroy()
    for node in created_nodes:
        node.destroy()

    del created_nodes[:]


def create_letter(letter, position, gap):

    def expression(field, name, gap, dimension=0, add=0):
        exp = 'value = thisGroup.' + name + \
            '.curve(frame - ' + str(gap) + '*thisGroup.delay_param.get());'
        exp += 'ret = value + ' + str(add)

        field.setExpression(exp, False, dimension)

    # create text
    text = createNode('text')
    text.autoSize.set(True)
    text.text.set(letter)
    # Opacity expression
    for i in range(4):
        expression(text.color, 'opacity_param', gap, i)
    # ------------------------

    # Blur
    blur = createNode('blur')
    blur.cropToFormat.set(False)
    blur.connectInput(0, text)
    expression(blur.size, 'blur_x_param', gap, 0)
    expression(blur.size, 'blur_y_param', gap, 1)
    # ------------------

    letter_width = text.getRegionOfDefinition(1, 1).x2

    transform = createNode('transform')

    # Transform expression
    expression(transform.translate, 'position_x_param', gap, 0, position)
    expression(transform.translate, 'position_y_param', gap, 1)
    expression(transform.rotate, 'rotate_param', gap)
    expression(transform.scale, 'scale_param', gap, 0)
    expression(transform.scale, 'scale_param', gap, 1)
    # -----------------------

    transform.connectInput(0, blur)
    
    return [transform, letter_width]


def create_word():  
    merge = createNode('merge')

    output = _thisNode.getNode("Output1")
    output.connectInput(0, merge)
    # -------------------
    
    word = _thisNode.text_param.get()
    idxs = range(len(word))

    # el desfase en el tiempo de las letras
    reverse = _thisNode.direction_param.get()
    if (reverse):
        gaps = reversed(idxs)
    else:
        gaps = idxs
    # ---------------
    
    pos = 0
    last_letter_width = 0
    for index, gap, letter in zip(idxs, gaps, word):
        # si la letra es un espacio agrega la posicion de la letra anterior
        # para que quede el espacio
        if letter == ' ':
            pos += last_letter_width
            continue
        # ------------------

        transform, letter_width = create_letter(letter.strip(), pos, gap)

        # la entrada numero 2 pertenece a la maskara, asi que la omite
        if index >= 2:
            index += 1

        merge.connectInput(index, transform)
        pos += letter_width
        last_letter_width = letter_width
